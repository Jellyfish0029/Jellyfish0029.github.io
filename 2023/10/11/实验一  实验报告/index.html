<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords"><meta name="descriptioon" content=""><meta name="renderer" content="wekit"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="/css/public.css"><link rel="stylesheet" href="/css/reset.css"><link rel="stylesheet" href="/css/iconfont.css"><title>实验一  实验报告 [ Jellyfish0029 ]</title><link rel="stylesheet" href="/css/partial/footer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><link rel="stylesheet" href="/css/partial/sidebar.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><meta name="generator" content="Hexo 6.3.0"></head><body class="scroll"><link rel="stylesheet" href="/css/partial/header.css"><div class="header scroll"><div class="maxwidth"><div class="nav"><a id="artlist" href="/404"><i class="iconfont icon404"></i><span class="headhid">&nbsp;404</span></a><a id="artlist" href="/archives"><i class="iconfont iconarchives"></i><span class="headhid">&nbsp;Archives</span></a><a id="artlist" href="/link"><i class="iconfont iconlink"></i><span class="headhid">&nbsp;Link</span></a><a id="artlist" href="/about"><i class="iconfont iconabout"></i><span class="headhid">&nbsp;About</span></a></div><div class="search">TONG-H</div></div></div><div class="main"> <div class="maxwidth"><link rel="stylesheet" href="/css/partial/sidebar.css"><div class="scroll" id="sidebar"><div class="social"><a href="/archives" title="Home"><i class="iconfont iconHome"></i></a><a href="mailto:tongt0232@gmail.com" title="E-Mail"><i class="iconfont iconweibiaoti554"></i></a><a target="_blank" rel="noopener" href="https://github.com/tong-h" title="GitHub"><i class="iconfont iconGitHub"></i></a><a target="_blank" rel="noopener" href="https://juejin.cn/user/1204720474809741" title="juejin"><img src="/images/juejinicon-sidebar.png"></a><a target="_blank" rel="noopener" href="https://www.jianshu.com/u/20de04cc53de" title="jianshu"><img src="/images/jianicon-sidebar.png"></a></div><div class="structure category-list"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-1-Manipulating-Environment-Variables"><span class="toc-number">1.</span> <span class="toc-text">*Task 1: Manipulating Environment Variables*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process"><span class="toc-number">2.</span> <span class="toc-text">*Task 2: Passing Environment Variables from Parent Process to Child Process*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-3-Environment-Variables-and-execve"><span class="toc-number">3.</span> <span class="toc-text">*Task 3: Environment Variables and execve()*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-4-Environment-Variables-and-system"><span class="toc-number">4.</span> <span class="toc-text">* Task 4: Environment Variables and system()*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-5-Environment-Variable-and-Set-UID-Programs"><span class="toc-number">5.</span> <span class="toc-text">*Task 5: Environment Variable and* Set-UID *Programs*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs"><span class="toc-number">6.</span> <span class="toc-text">*Task 6: The PATH Environment Variable and* Set-UID *Programs*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs"><span class="toc-number">7.</span> <span class="toc-text">*Task 7: The* LD PRELOAD *Environment Variable and* Set-UID *Programs*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-8-Invoking-External-Programs-Using-system-versus-execve"><span class="toc-number">8.</span> <span class="toc-text">*Task 8: Invoking External Programs Using* system() *versus* execve()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Task-9-Capability-Leaking"><span class="toc-number">9.</span> <span class="toc-text">*Task 9: Capability Leaking*</span></a></li></ol></div><div class="tags"></div></div><div class="post rightside"><div class="artititle">实验一  实验报告</div><div class="info"><i class="iconfont iconshijian"><span title="文章发布时间">2023-10-11</span></i></div><div class="postDetail"><h2 id="Task-1-Manipulating-Environment-Variables"><a href="#Task-1-Manipulating-Environment-Variables" class="headerlink" title="*Task 1: Manipulating Environment Variables*"></a><em><strong>*Task 1: Manipulating Environment Variables*</strong></em></h2><p>• Use printenv or env command to print out the environment variables. </p>
<p>• Use export and unset to set or unset environment variables.</p>
<p>使用printenv输出环境变量的值</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps1.jpg" alt="img"> </p>
<p>输出一个特定的环境变量</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps2.jpg" alt="img"> </p>
<p> printenv和env是程序，新开启一个子进程。</p>
<p>使用export和unset设置或删除环境变量：</p>
<p>用户定义的shell变量LOGNAME3 ，export后成为子进程1的环境变量之一，通过unset删除环境变量LOGNAME，子进程2中环境变量只剩下LOGNAME3，再删除LOGNAME3，子进程3中没有一个环境变量。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps3.jpg" alt="img"></p>
<p>export和unset是shell命令，在当前进程中处理。</p>
<h2 id="Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process"><a href="#Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process" class="headerlink" title="*Task 2: Passing Environment Variables from Parent Process to Child Process*"></a><em><strong>*Task 2: Passing Environment Variables from Parent Process to Child Process*</strong></em></h2><p>In this task, we would like to know whether the parent’s environment variables are inherited by the child process or not.</p>
<p>观察子进程是否继承了父进程的环境变量。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps4.jpg" alt="img"><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps5.jpg" alt="img"> </p>
<p>①处打印子进程的环境变量，输出到文件file</p>
<p>②处打印父进程的环境变量，输出到文件file2</p>
<p>使用diff命令查看两者的不同：</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps6.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps7.jpg" alt="img"> </p>
<p>两者完全相同。</p>
<p>结论：子进程继承了父进程的所有环境变量。</p>
<h2 id="Task-3-Environment-Variables-and-execve"><a href="#Task-3-Environment-Variables-and-execve" class="headerlink" title="*Task 3: Environment Variables and execve()*"></a><em><strong>*Task 3: Environment Variables and execve()*</strong></em></h2><p>We are interested in what happens to the environment variables; are they automatically inherited by the new program? </p>
<p>环境变量如何被传递给新的程序？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">extern char **environ;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">char *argv[2];</span><br><span class="line"></span><br><span class="line">argv[0] = &quot;/usr/bin/env&quot;;</span><br><span class="line"></span><br><span class="line">argv[1] = NULL;</span><br><span class="line"></span><br><span class="line">execve(&quot;/usr/bin/env&quot;, argv, NULL); ➀</span><br><span class="line"></span><br><span class="line">return 0 ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>➀修改前：没有输出</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps8.jpg" alt="img"> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/usr/bin/env&quot;, argv, environ);②</span><br></pre></td></tr></table></figure>

<p>②修改后：输出环境变量</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps9.jpg" alt="img"> </p>
<p><em><strong>*Step 3.*</strong></em> </p>
<p>Please draw your conclusion regarding how the new program gets its environment variables.</p>
<p>结论：利用execve执行新的程序时，程序从execve的第三个参数处获得环境变量，用户可以通过修改参数来指定环境变量。</p>
<blockquote>
<p>那么，为什么argv数组的第一个元素要和execve()函数的第一个参数一样，都是执行程序的路径和名称呢？这是因为这是一个约定，也是一个传统。大多数的执行程序都会遵守这个约定，也就是说，它们会认为argv数组的第一个元素是它们自己的路径和名称，而不是一个普通的参数。这样做的好处是，执行程序可以知道自己是从哪里启动的，也可以知道自己叫什么名字，从而可以根据不同的情况做出不同的响应。</p>
<p>例如，&#x2F;usr&#x2F;bin&#x2F;env这个程序可以根据参数来打印或修改环境变量。如果没有参数，它就会打印出当前进程的环境变量。如果有参数，它就会根据参数的格式来修改或添加环境变量，或者执行另一个程序，并传递给它修改后的环境变量。 但是，如果argv数组的第一个元素不是&#x2F;usr&#x2F;bin&#x2F;env，而是其他的字符串，那么这个程序就会认为这是一个普通的参数，而不是它自己的路径和名称，从而会产生错误的结果。</p>
<p>所以，为了保证execve()函数能正确地执行程序，并且程序能正确地获取参数，我们需要遵守这个约定，也就是让argv数组的第一个元素和execve()函数的第一个参数一样，都是执行程序的路径和名称。</p>
</blockquote>
<h2 id="Task-4-Environment-Variables-and-system"><a href="#Task-4-Environment-Variables-and-system" class="headerlink" title="* Task 4: Environment Variables and system()*"></a><em><strong>* Task 4: Environment Variables and system()*</strong></em></h2><p>If you look at the implementation of the system() function, you will see that it uses execl() to execute &#x2F;bin&#x2F;sh; execl() calls execve(), passing to it the environment variables array. Therefore, using system(), the environment variables of the calling process is passed to the new program &#x2F;bin&#x2F;sh. </p>
<p>Please compile and run the following program to verify this. </p>
<p>验证：使用system()时，当前进程的环境变量被转递给一个新的shell程序。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps10.jpg" alt="img"> </p>
<p>打印出了当前进程的环境变量。这些环境变量是在调用system()时传入&#x2F;bin&#x2F;sh。</p>
<h2 id="Task-5-Environment-Variable-and-Set-UID-Programs"><a href="#Task-5-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="*Task 5: Environment Variable and* Set-UID *Programs*"></a><em><strong>*Task 5: Environment Variable and*</strong></em> Set-UID <em><strong>*Programs*</strong></em></h2><p>To understand how Set-UID programs are affected, let us first figure out whether environment variables are inherited by the Set-UID program’s process from the user’s process.</p>
<p>用户可以通过环境变量来影响Set-UID程序的行为。</p>
<p>step1：将下列C代码编译为2-5.out，它的作用是打印当前进程的环境变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">extern char **environ;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">while (environ[i] != NULL) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, environ[i]);</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>step2：将2-5.out设置为Set-UID程序，并导出修改后的PATH、LD_LIBRARY_PATH、LOGNANE,在运行2-5.out时，会唤起子进程时，以上变量会成为子进程的环境变量。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps11.jpg" alt="img"> </p>
<p>找出PATH、LD_LIBRARY_PATH、LOGNANE，观察他们的值。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps12.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps13.jpg" alt="img"> </p>
<p>可以看到PATH和LOGNAME都被修改了。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps14.jpg" alt="img"> </p>
<p>而LD_LIBRARY_PATH未被打印。这是因为保护策略：当一个程序为Set-UID程序时，EUID和RUID往往不同，此时动态连接器忽略环境变脸中的 LD_PRELOAD 和 LD_LIBRARY_PATH。</p>
<h2 id="Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs"><a href="#Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="*Task 6: The PATH Environment Variable and* Set-UID *Programs*"></a><em><strong>*Task 6: The PATH Environment Variable and*</strong></em> Set-UID <em><strong>*Programs*</strong></em></h2><p>Please compile the above program, change its owner to root, and make it a Set-UID program. Can</p>
<p>you get this Set-UID program to run your own malicious code, instead of &#x2F;bin&#x2F;ls? If you can, is your malicious code running with the root privilege? Describe and explain your observations.</p>
<p>修改PATH变量，通过2-6.out执行其他命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=/home/seed:$PATH</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">system(&quot;ls&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在&#x2F;home&#x2F;seed目录下编写一个名为ls的.c文件并将其编译为ls，这个程序的代码是利用execve运行&#x2F;bin&#x2F;sh程序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">  char *args[] = &#123;&quot;/bin/sh&quot;, NULL&#125;;</span><br><span class="line"></span><br><span class="line">  char *env[] = &#123;NULL&#125;;</span><br><span class="line"></span><br><span class="line">  execve(&quot;/bin/sh&quot;, args, env);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">perror(&quot;execve&quot;);</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将task 6 中给出的代码编译成可执行文件，并将其设置为Set-UID程序。因为程序中使用的是相对路径，所以运行时会在PATH中寻找程序的绝对路径。修改PATH变量，使&#x2F;home&#x2F;seed放在原PATH之前，当程序运行时，会先在&#x2F;home&#x2F;seed中寻找ls并运行。</p>
<p>此时运行了自定义的ls,获得了root shell，可以执行各种命令。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps15.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps16.jpg" alt="img"></p>
<h2 id="Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs"><a href="#Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="*Task 7: The* LD PRELOAD *Environment Variable and* Set-UID *Programs*"></a><em><strong>*Task 7: The*</strong></em> LD PRELOAD <em><strong>*Environment Variable and*</strong></em> Set-UID <em><strong>*Programs*</strong></em></h2><p>In Linux, ld.so or ld-linux.so, are the dynamic loader&#x2F;linker (each for different types of binary). In this task, we will only study LD PRELOAD. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void sleep (int s)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">/* If this is invoked by a privileged program,</span><br><span class="line"></span><br><span class="line">you can do damages here! */</span><br><span class="line"></span><br><span class="line">printf(&quot;I am not sleeping!\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -fPIC -g -c mylib.c </span><br><span class="line"></span><br><span class="line">$ gcc -shared -o libmylib.so.1.0.1 mylib.o -lc </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export LD_PRELOAD=./libmylib.so.1.0.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* myprog.c */ </span><br><span class="line"></span><br><span class="line">\#include &lt;unistd.h&gt; </span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">sleep(1); </span><br><span class="line"></span><br><span class="line">return 0; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>• 7.1  Make myprog a regular program, and run it as a normal user. </p>
<p>普通程序直接运行，链接到自定义的动态库，输出 I am not sleeping!</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps17.jpg" alt="img"> </p>
<p>• 7.2  Make myprog a Set-UID root program, and run it as a normal user</p>
<p>Set-UID（owner&#x3D;root）程序运行，程序执行sleep(),休眠1秒。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps18.jpg" alt="img"> </p>
<p>• 7.3  Make myprog a Set-UID root program, export the LD PRELOAD environment variable again in the root account and run it. </p>
<p>Set-UID程序运行(owner&#x3D;root)，程序执行sleep(),休眠1秒。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps19.jpg" alt="img"> </p>
<p>• 7.4 Make myprog a Set-UID user1 program (i.e., the owner is user1, which is another user account), export the LD PRELOAD environment variable again in a different user’s account (not-root user) and run it. </p>
<p>Set-UID（owner&#x3D;jelly,普通用户）程序运行，链接到自定义的动态库，输出 I am not sleeping!</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps20.jpg" alt="img"> </p>
<p>结论：这是因为保护策略：当一个程序为Set-UID程序时，EUID和RUID不同，EUID&#x3D;root时，此时动态连接器忽略环境变量中的 LD_PRELOAD 和 LD_LIBRARY_PATH。</p>
<p>实验验证：导出shell变量LD_PRELOAD、LD_LIBRARY_PATH、LD_MYOWN作为子进程的环境变量，先使用env打印子进程1的环境变量，以为env使普通程序，所以LD_PRELOAD、LD_LIBRARY_PATH被修改了。再使用myenv打印子进程2的环境变量，本应继承子进程1中的LD_PRELOAD、LD_LIBRARY_PATH，但是由于myenv是root的Set-UID程序，LD_PRELOAD、LD_LIBRARY_PATH因为保护策略而被忽略。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps21.jpg" alt="img"><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps22.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps23.jpg" alt="img"> </p>
<h2 id="Task-8-Invoking-External-Programs-Using-system-versus-execve"><a href="#Task-8-Invoking-External-Programs-Using-system-versus-execve" class="headerlink" title="*Task 8: Invoking External Programs Using* system() *versus* execve()"></a><em><strong>*Task 8: Invoking External Programs Using*</strong></em> system() <em><strong>*versus*</strong></em> execve()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//catall.c</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">char *v[3];</span><br><span class="line"></span><br><span class="line">char *command;</span><br><span class="line"></span><br><span class="line">if(argc &lt; 2) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;Please type a file name.\n&quot;);</span><br><span class="line"></span><br><span class="line">return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v[0] = &quot;/bin/cat&quot;; v[1] = argv[1]; v[2] = NULL;</span><br><span class="line"></span><br><span class="line">command = malloc(strlen(v[0]) + strlen(v[1]) + 2);</span><br><span class="line"></span><br><span class="line">sprintf(command, &quot;%s %s&quot;, v[0], v[1]);</span><br><span class="line"></span><br><span class="line">// Use only one of the followings.</span><br><span class="line"></span><br><span class="line">system(command);</span><br><span class="line"></span><br><span class="line">// execve(v[0], v, NULL);</span><br><span class="line"></span><br><span class="line">return 0 ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将catall设置为Set-UID程序。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps24.jpg" alt="img"> </p>
<p>要打印的文件为a.txt，其中只有一行“hello”。</p>
<p>在命令后加上“;&#x2F;bin&#x2F;sh”,system会在shell中调用catall和sh，由于是root-owned的SET UID程序，所以获取了root shell</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps25.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps26.jpg" alt="img"> </p>
<p>使用execve，则不会经过shell，直接执行程序，把“a.txt ;&#x2F;bin&#x2F;sh”当作文件名，此时会报错，避免了漏洞。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps27.jpg" alt="img"> </p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps28.jpg" alt="img"> </p>
<h2 id="Task-9-Capability-Leaking"><a href="#Task-9-Capability-Leaking" class="headerlink" title="*Task 9: Capability Leaking*"></a><em><strong>*Task 9: Capability Leaking*</strong></em></h2><p>Compile the following program, change its owner to root, and make it a Set-UID program. Run the program as a normal user. Can you exploit the capability leaking vulnerability in this program? The goal is to write to the &#x2F;etc&#x2F;zzz file as a normal user. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int fd;</span><br><span class="line"></span><br><span class="line">char *v[2];</span><br><span class="line"></span><br><span class="line">fd = open(&quot;/etc/zzz&quot;, O_RDWR | O_APPEND);</span><br><span class="line"></span><br><span class="line">if (fd == -1) &#123;</span><br><span class="line"></span><br><span class="line">printf(&quot;Cannot open /etc/zzz\n&quot;);</span><br><span class="line"></span><br><span class="line">exit(0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Print out the file descriptor value</span><br><span class="line"></span><br><span class="line">printf(&quot;fd is %d\n&quot;, fd);</span><br><span class="line"></span><br><span class="line">// Permanently disable the privilege by making the effective uid the same as the real uid</span><br><span class="line"></span><br><span class="line">setuid(getuid());</span><br><span class="line"></span><br><span class="line">// Execute /bin/sh</span><br><span class="line"></span><br><span class="line">v[0] = &quot;/bin/sh&quot;; v[1] = 0;</span><br><span class="line"></span><br><span class="line">execve(v[0], v, 0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在etc目录下创建zzz文件</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps29.jpg" alt="img"> </p>
<p>在普通用户状态下尝试写入&#x2F;etc&#x2F;zzz，但是没有权限。</p>
<p>文件描述符fd被打开后没有被关闭，在调用子进程shell时被传递给子进程，造成权限泄露。</p>
<p>在子进程shell中向文件中成功写入hello。</p>
<p><img src="file:///C:\Users\向佳\AppData\Local\Temp\ksohtml9608\wps30.jpg" alt="img"> </p>
</div></div><link rel="stylesheet" href="/css/partial/footer.css"><div class="footer"><p><span>Copyright © 2017 - 2023</span><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">蜀ICP备19024124号</a></p><p><i class="iconfont iconchakan"><span>本站总访问量</span><span id="busuanzi_container_site_pv">  <span id="busuanzi_value_site_pv"></span> </span></i><i class="iconfont iconabout"><span>本站访客数</span><span id="busuanzi_container_site_uv">  <span id="busuanzi_value_site_uv"></span> </span></i></p></div></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>